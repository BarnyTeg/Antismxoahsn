local Players = game:GetService("Players")
local player = Players.LocalPlayer
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")

-- Настройки логгирования
local LOG_INTERVAL = 1 -- сек (интервал сохранения логов)
local MAX_LOG_LENGTH = 5000 -- макс. строк в логе
local LOG_TO_CLIPBOARD = true -- копировать в буфер обмена
local LOG_TO_FILE = false -- сохранять в файл (если возможно)

-- Глобальный лог
local ActionLog = {}
local LastLogTime = os.time()

-- Функция для форматирования данных
local function formatValue(value)
    if typeof(value) == "table" then
        return HttpService:JSONEncode(value)
    elseif typeof(value) == "Vector3" then
        return string.format("(%.2f, %.2f, %.2f)", value.X, value.Y, value.Z)
    else
        return tostring(value)
    end
end

-- Логгирование действия
local function logAction(category, action, details)
    local timestamp = os.date("%H:%M:%S")
    local entry = string.format("[%s][%s] %s: %s", timestamp, category, action, details)
    
    table.insert(ActionLog, entry)
    
    -- Очистка старых записей
    if #ActionLog > MAX_LOG_LENGTH then
        table.remove(ActionLog, 1)
    end
    
    -- Автосохранение
    if os.time() - LastLogTime >= LOG_INTERVAL then
        local fullLog = table.concat(ActionLog, "\n")
        if LOG_TO_CLIPBOARD then
            pcall(function() setclipboard(fullLog) end)
        end
        if LOG_TO_FILE then
            pcall(function() writefile("action_log.txt", fullLog) end)
        end
        LastLogTime = os.time()
    end
    
    print(entry)
end

-- Мониторинг кликов и касаний
local function monitorInputs()
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        local inputType = input.UserInputType.Name
        local position = input.Position or Vector3.new(0, 0, 0)
        
        logAction("INPUT", inputType, string.format(
            "Position: %s | KeyCode: %s", 
            formatValue(position), 
            input.KeyCode.Name
        ))
    end)
end

-- Мониторинг изменений свойств объектов
local function monitorPropertyChanges()
    local function trackObject(obj)
        for prop, _ in pairs(getproperties(obj)) do
            if not pcall(function()
                local oldValue = obj[prop]
                
                -- Следим за изменениями
                local conn; conn = obj:GetPropertyChangedSignal(prop):Connect(function()
                    local newValue = obj[prop]
                    logAction("PROPERTY", "CHANGE", string.format(
                        "%s.%s: %s → %s [ID: %s]",
                        obj.Name, prop, 
                        formatValue(oldValue), 
                        formatValue(newValue),
                        obj:GetDebugId()
                    ))
                    oldValue = newValue
                end)
            end) then
                -- Игнорируем ошибки
            end
        end
    end
    
    -- Отслеживаем новые объекты
    workspace.DescendantAdded:Connect(trackObject)
    for _, obj in ipairs(workspace:GetDescendants()) do
        trackObject(obj)
    end
end

-- Мониторинг сетевых событий
local function monitorNetwork()
    for _, obj in ipairs(game:GetDescendants()) do
        if obj:IsA("RemoteEvent") then
            obj.OnClientEvent:Connect(function(...)
                local args = {...}
                logAction("NETWORK", "REMOTE_EVENT", string.format(
                    "%s (ID: %s) | Args: %s",
                    obj.Name, obj:GetDebugId(), formatValue(args)
                ))
            end)
        elseif obj:IsA("RemoteFunction") then
            local oldInvoke = obj.InvokeServer
            obj.InvokeServer = function(self, ...)
                local args = {...}
                logAction("NETWORK", "REMOTE_INVOKE", string.format(
                    "%s (ID: %s) | Args: %s",
                    obj.Name, obj:GetDebugId(), formatValue(args)
                ))
                return oldInvoke(self, ...)
            end
        end
    end
end

-- Мониторинг изменений в инвентаре (если есть)
local function monitorInventory()
    if not player:FindFirstChild("Backpack") then return end
    
    player.Backpack.ChildAdded:Connect(function(item)
        logAction("INVENTORY", "ITEM_ADDED", string.format(
            "%s (Class: %s, ID: %s)", 
            item.Name, item.ClassName, item:GetDebugId()
        ))
    end)
    
    player.Backpack.ChildRemoved:Connect(function(item)
        logAction("INVENTORY", "ITEM_REMOVED", string.format(
            "%s (Class: %s, ID: %s)", 
            item.Name, item.ClassName, item:GetDebugId()
        ))
    end)
end

-- Мониторинг запуска скриптов
local function monitorScripts()
    for _, script in ipairs(game:GetDescendants()) do
        if script:IsA("Script") or script:IsA("LocalScript") then
            logAction("SCRIPT", "DETECTED", string.format(
                "%s (Type: %s, ID: %s, Disabled: %s)", 
                script.Name, script.ClassName, script:GetDebugId(), script.Disabled
            ))
        end
    end
end

-- Мониторинг физических взаимодействий
local function monitorPhysics()
    workspace.DescendantAdded:Connect(function(obj)
        if obj:IsA("BasePart") then
            obj.Touched:Connect(function(otherPart)
                logAction("PHYSICS", "COLLISION", string.format(
                    "%s (ID: %s) ↔ %s (ID: %s)", 
                    obj.Name, obj:GetDebugId(), 
                    otherPart.Name, otherPart:GetDebugId()
                ))
            end)
        end
    end)
end

-- Запуск всех мониторов
monitorInputs()
monitorPropertyChanges()
monitorNetwork()
monitorInventory()
monitorScripts()
monitorPhysics()

logAction("SYSTEM", "START", "Мониторинг активирован. Все действия записываются.")
